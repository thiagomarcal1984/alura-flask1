A variável __name__ é o nome do módulo atual.

Se você roda "python principal.py", e __name__ é chamada desse arquivo 
principal, ela vale __main__.

Mas se __name__ é obtida de um arquivo importado de modulo xpto.py, então seu
valor é o nome do módulo importado (xpto).

No Flask, usamos o seguinte código para criar uma aplicação a partir do arquivo
atual (que deve ser referenciado como __main__ na aplicação):
    app = Flask(__name__)


Para cada rota na aplicação, use a anotação app.route e coloque como parâmetro
o path precedido de uma barra ("/exemplo"):
    @app.route("/inicio")
    def metodo():
        return "<b>Código HTML</b>."

Para rodar a aplicação, primeiro atribua à variável de ambiente FLASK_APP o 
nome do arquivo que vai conter as configurações da aplicação e depois 
execute o comando flask run:
    $Env:FLASK_APP="jogoteca.py"
    flask run --port 8080

Existem mais formas de definir ou restringir versões a serem instaladas no seu
ambiente com pip. Vamos ver alguns exemplos:

~=:     versão compatível - pode ser qualquer versão mais atual que não quebre
        compatibilidade com a definida.
==:     versão exata - define uma versão fixa que deve ser instalada.
!=:     exclusão de versão - define a versão que não é para instalar, 
        pegando assim a mais atual sem ser a definida.
<=, >=: versão maior ou igual e menor ou igual - ajuda a restringir 
        versões, inclusive a definida.
<, >:   versão maior ou menor - ajuda a restringir versões, excluindo 
        a definida.

Por exemplo: em requirements.txt definimos a versão 2.0.2 do Flask com ~=.
Assim, a versão mais recente que é compatível com a 2.0.2 é a 2.0.3.

O método render_template, por padrão, busca os arquivos HTML a partir da pasta
templates.

Para enviar parâmetros para os templates, basta inserir parâmetros nomeados 
para o método render_template:
    @app.route("/rota1")
    def rota1():
        return render_template("arquivo.html", parm1="Um", parm2="Dois")

A diretiva para loop for no Flask é:
    {% for obj in items %}
        <p>{{ obj.valor }}</p>
    {% endfor %}

Padrão de criação de uma classe com construtor em Python:
    class Classe:
        def __init__(self, parm1, parm2, parm3):
            self.parm1 = parm1
            self.parm2 = parm2
            self.parm3 = parm3

O Flask dispõe de um helper chamado request para tratar dados da requisição.
Ele precisa ser importado da biblioteca para ser usado (não é um objeto 
fornecido para o método, como no Django).

A lista de jogos foi removida do método início, e foi passada para um 
escopo global.

O método POST não é permitido no Flask por padrão. Como resolver?

Basta fornecer para @app.route o array com os métodos permitidos para a rota:
    @app.route('/rota', methods=['POST', 'GET'])
        def rota():
            # Processamento da requisição
            return render_template("path_do_template")


Para evitar os reloads manuais no ambiente de desenvolvimento, basta ligar o 
debug mode no arquivo da aplicação Flask:
    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=True)

Para habilitar o debug mode no comando "flask run", defina a variável de 
ambiente FLASK_ENV para development:
    $Env:FLASK_ENV="development"

Tratamentos de mensagens POST devem REDIRECIONAR a resposta para outra rota.
Isso impede aquela mensagem perguntando se você deseja repetir a postagem.

Assim como o request, o objeto redirect é um objeto que pode ser importado da
biblioteca Flask.
